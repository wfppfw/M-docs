import{_ as e,o as t,c as r,a as o}from"./app.04ed3e28.js";const m=JSON.parse('{"title":"Cross-origin XMLHttpRequest","description":"","frontmatter":{},"headers":[{"level":2,"title":"# Extension origin","slug":"extension-origin","link":"#extension-origin","children":[]},{"level":2,"title":"# Requesting cross-origin permissions","slug":"requesting-cross-origin-permissions","link":"#requesting-cross-origin-permissions","children":[]},{"level":2,"title":"# Security considerations","slug":"security-considerations","link":"#security-considerations","children":[{"level":3,"title":"# Avoiding cross-site scripting vulnerabilities","slug":"avoiding-cross-site-scripting-vulnerabilities","link":"#avoiding-cross-site-scripting-vulnerabilities","children":[]},{"level":3,"title":"# Limiting content script access to cross-origin requests","slug":"limiting-content-script-access-to-cross-origin-requests","link":"#limiting-content-script-access-to-cross-origin-requests","children":[]},{"level":3,"title":"# Preferring HTTPS over HTTP","slug":"preferring-https-over-http","link":"#preferring-https-over-http","children":[]},{"level":3,"title":"# Adjusting the content security policy","slug":"adjusting-the-content-security-policy","link":"#adjusting-the-content-security-policy","children":[]}]}],"relativePath":"chromedocs/In depth_ security/Cross-origin XMLHttpRequest - Chrome Developers.md","lastUpdated":1679926139000}'),s={name:"chromedocs/In depth_ security/Cross-origin XMLHttpRequest - Chrome Developers.md"},n=o(`<ul><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#extension-origin" target="_blank" rel="noreferrer">Extension origin</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#requesting-permission" target="_blank" rel="noreferrer">Requesting cross-origin permissions</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#security-considerations" target="_blank" rel="noreferrer">Security considerations</a><ul><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#xss" target="_blank" rel="noreferrer">Avoiding cross-site scripting vulnerabilities</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#xhr-vs-content-scripts" target="_blank" rel="noreferrer">Limiting content script access to cross-origin requests</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#http-man-in-the-middle" target="_blank" rel="noreferrer">Preferring HTTPS over HTTP</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#interaction-with-csp" target="_blank" rel="noreferrer">Adjusting the content security policy</a></li></ul></li></ul><h1 id="cross-origin-xmlhttprequest" tabindex="-1">Cross-origin XMLHttpRequest <a class="header-anchor" href="#cross-origin-xmlhttprequest" aria-hidden="true">#</a></h1><p>Published on Tuesday, September 18, 2012 \u2022 Updated on Monday, March 9, 2020</p><ul><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#extension-origin" target="_blank" rel="noreferrer">Extension origin</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#requesting-permission" target="_blank" rel="noreferrer">Requesting cross-origin permissions</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#security-considerations" target="_blank" rel="noreferrer">Security considerations</a><ul><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#xss" target="_blank" rel="noreferrer">Avoiding cross-site scripting vulnerabilities</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#xhr-vs-content-scripts" target="_blank" rel="noreferrer">Limiting content script access to cross-origin requests</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#http-man-in-the-middle" target="_blank" rel="noreferrer">Preferring HTTPS over HTTP</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#interaction-with-csp" target="_blank" rel="noreferrer">Adjusting the content security policy</a></li></ul></li></ul><p>Warning</p><p>In Manifest V3, <code>XMLHttpRequest</code> is not supported in background pages (provided by Service Workers). Please consider using its modern replacement, <code>fetch()</code>.</p><p>Regular web pages can use the <a href="https://www.w3.org/TR/XMLHttpRequest/" target="_blank" rel="noreferrer"><code>XMLHttpRequest</code></a> object to send and receive data from remote servers, but they&#39;re limited by the <a href="https://en.wikipedia.org/wiki/Same_origin_policy" target="_blank" rel="noreferrer">same origin policy</a>. <a href="https://developer.chrome.com/docs/extensions/mv3/content_scripts/" target="_blank" rel="noreferrer">Content scripts</a> initiate requests on behalf of the web origin that the content script has been injected into and therefore content scripts are also subject to the <a href="https://en.wikipedia.org/wiki/Same_origin_policy" target="_blank" rel="noreferrer">same origin policy</a>. (Content scripts have been subject to <a href="https://www.chromium.org/Home/chromium-security/extension-content-script-fetches" target="_blank" rel="noreferrer">CORB since Chrome 73 and CORS since Chrome 83</a>.) Extension origins aren&#39;t so limited - a script executing in an extension&#39;s background page or foreground tab can talk to remote servers outside of its origin, as long as the extension requests cross-origin permissions.</p><h2 id="extension-origin" tabindex="-1"><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#extension-origin" target="_blank" rel="noreferrer">#</a> Extension origin <a class="header-anchor" href="#extension-origin" aria-hidden="true">#</a></h2><p>Each running extension exists within its own separate security origin. Without requesting additional privileges, the extension can use <code>XMLHttpRequest</code> to get resources within its installation. For example, if an extension contains a JSON configuration file called <code>config.json</code>, in a <code>config_resources</code> folder, the extension can retrieve the file&#39;s contents like this:</p><pre><code>var xhr = new XMLHttpRequest();xhr.onreadystatechange = handleStateChange; // Implemented elsewhere.xhr.open(&quot;GET&quot;, chrome.extension.getURL(&#39;/config_resources/config.json&#39;), true);xhr.send();
</code></pre><p>If the extension attempts to use a security origin other than itself, say <a href="https://www.google.com" target="_blank" rel="noreferrer">https://www.google.com</a>, the browser disallows it unless the extension has requested the appropriate cross-origin permissions.</p><h2 id="requesting-cross-origin-permissions" tabindex="-1"><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#requesting-permission" target="_blank" rel="noreferrer">#</a> Requesting cross-origin permissions <a class="header-anchor" href="#requesting-cross-origin-permissions" aria-hidden="true">#</a></h2><p>By adding hosts or host match patterns (or both) to the <a href="https://developer.chrome.com/docs/extensions/mv3/declare_permissions/" target="_blank" rel="noreferrer">host_permissions</a> section of the <a href="https://developer.chrome.com/docs/extensions/mv3/manifest/" target="_blank" rel="noreferrer">manifest</a> file, the extension can request access to remote servers outside of its origin.</p><pre><code>{  &quot;name&quot;: &quot;My extension&quot;,  ...  &quot;host_permissions&quot;: [    &quot;https://www.google.com/&quot;  ],  ...}
</code></pre><p>Cross-origin permission values can be fully qualified host names, like these:</p><ul><li>&quot;<a href="https://www.google.com/" target="_blank" rel="noreferrer">https://www.google.com/</a>&quot;</li><li>&quot;<a href="https://www.gmail.com/" target="_blank" rel="noreferrer">https://www.gmail.com/</a>&quot;</li></ul><p>Or they can be match patterns, like these:</p><ul><li>&quot;https://*.google.com/&quot;</li><li>&quot;https://*/&quot;</li></ul><p>A match pattern of &quot;https://*/&quot; allows HTTPS access to all reachable domains. Note that here, match patterns are similar to <a href="https://developer.chrome.com/docs/extensions/mv3/match_patterns/" target="_blank" rel="noreferrer">content script match patterns</a>, but any path information following the host is ignored.</p><p>Also note that access is granted both by host and by scheme. If an extension wants both secure and non-secure HTTP access to a given host or set of hosts, it must declare the permissions separately:</p><pre><code>&quot;host_permissions&quot;: [  &quot;http://www.google.com/&quot;,  &quot;https://www.google.com/&quot;]
</code></pre><h2 id="security-considerations" tabindex="-1"><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#security-considerations" target="_blank" rel="noreferrer">#</a> Security considerations <a class="header-anchor" href="#security-considerations" aria-hidden="true">#</a></h2><h3 id="avoiding-cross-site-scripting-vulnerabilities" tabindex="-1"><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#xss" target="_blank" rel="noreferrer">#</a> Avoiding cross-site scripting vulnerabilities <a class="header-anchor" href="#avoiding-cross-site-scripting-vulnerabilities" aria-hidden="true">#</a></h3><p>When using resources retrieved via <code>XMLHttpRequest</code>, your background page should be careful not to fall victim to <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noreferrer">cross-site scripting</a>. Specifically, avoid using dangerous APIs such as the below:</p><pre><code>var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;https://api.example.com/data.json&quot;, true);xhr.onreadystatechange = function() {  if (xhr.readyState == 4) {    // WARNING! Might be evaluating an evil script!    var resp = eval(&quot;(&quot; + xhr.responseText + &quot;)&quot;);    ...  }}xhr.send();

var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;https://api.example.com/data.json&quot;, true);xhr.onreadystatechange = function() {  if (xhr.readyState == 4) {    // WARNING! Might be injecting a malicious script!    document.getElementById(&quot;resp&quot;).innerHTML = xhr.responseText;    ...  }}xhr.send();
</code></pre><p>Instead, prefer safer APIs that do not run scripts:</p><pre><code>var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;https://api.example.com/data.json&quot;, true);xhr.onreadystatechange = function() {  if (xhr.readyState == 4) {    // JSON.parse does not evaluate the attacker&#39;s scripts.    var resp = JSON.parse(xhr.responseText);  }}xhr.send();

var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;https://api.example.com/data.json&quot;, true);xhr.onreadystatechange = function() {  if (xhr.readyState == 4) {    // textContent does not let the attacker inject HTML elements.    document.getElementById(&quot;resp&quot;).textContent = xhr.responseText;  }}xhr.send();
</code></pre><h3 id="limiting-content-script-access-to-cross-origin-requests" tabindex="-1"><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#xhr-vs-content-scripts" target="_blank" rel="noreferrer">#</a> Limiting content script access to cross-origin requests <a class="header-anchor" href="#limiting-content-script-access-to-cross-origin-requests" aria-hidden="true">#</a></h3><p>When performing cross-origin requests on behalf of a content script, be careful to <a href="https://developer.chrome.com/docs/extensions/mv3/security#content_scripts" target="_blank" rel="noreferrer">guard against malicious web pages</a> that might try to impersonate a content script. In particular, do not allow content scripts to request an arbitrary URL.</p><p>Consider an example where an extension performs a cross-origin request to let a content script discover the price of an item. One (insecure) approach would be to have the content script specify the exact resource to be fetched by the background page.</p><pre><code>chrome.runtime.onMessage.addListener(    function(request, sender, sendResponse) {      if (request.contentScriptQuery == &#39;fetchUrl&#39;) {        // WARNING: SECURITY PROBLEM - a malicious web page may abuse        // the message handler to get access to arbitrary cross-origin        // resources.        fetch(request.url)            .then(response =&gt; response.text())            .then(text =&gt; sendResponse(text))            .catch(error =&gt; ...)        return true;  // Will respond asynchronously.      }    });

chrome.runtime.sendMessage(    {contentScriptQuery: &#39;fetchUrl&#39;,     url: &#39;https://another-site.com/price-query?itemId=&#39; +              encodeURIComponent(request.itemId)},    response =&gt; parsePrice(response.text()));
</code></pre><p>In the approach above, the content script can ask the extension to fetch any URL that the extension has access to. A malicious web page may be able to forge such messages and trick the extension into giving access to cross-origin resources.</p><p>Instead, design message handlers that limit the resources that can be fetched. Below, only the <code>itemId</code> is provided by the content script, and not the full URL.</p><pre><code>chrome.runtime.onMessage.addListener(    function(request, sender, sendResponse) {      if (request.contentScriptQuery == &#39;queryPrice&#39;) {        var url = &#39;https://another-site.com/price-query?itemId=&#39; +            encodeURIComponent(request.itemId);        fetch(url)            .then(response =&gt; response.text())            .then(text =&gt; parsePrice(text))            .then(price =&gt; sendResponse(price))            .catch(error =&gt; ...)        return true;  // Will respond asynchronously.      }    });

chrome.runtime.sendMessage(    {contentScriptQuery: &#39;queryPrice&#39;, itemId: 12345},    price =&gt; ...);
</code></pre><h3 id="preferring-https-over-http" tabindex="-1"><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#http-man-in-the-middle" target="_blank" rel="noreferrer">#</a> Preferring HTTPS over HTTP <a class="header-anchor" href="#preferring-https-over-http" aria-hidden="true">#</a></h3><p>Additionally, be especially careful of resources retrieved via HTTP. If your extension is used on a hostile network, an network attacker (aka a <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noreferrer">&quot;man-in-the-middle&quot;</a>) could modify the response and, potentially, attack your extension. Instead, prefer HTTPS whenever possible.</p><h3 id="adjusting-the-content-security-policy" tabindex="-1"><a href="https://developer.chrome.com/docs/extensions/mv3/xhr/#interaction-with-csp" target="_blank" rel="noreferrer">#</a> Adjusting the content security policy <a class="header-anchor" href="#adjusting-the-content-security-policy" aria-hidden="true">#</a></h3><p>If you modify the default <a href="https://developer.chrome.com/docs/extensions/mv3/intro/mv3-migration/#content-security-policy" target="_blank" rel="noreferrer">Content Security Policy</a> for your extension by adding a <code>content_security_policy</code> attribute to your manifest, you&#39;ll need to ensure that any hosts to which you&#39;d like to connect are allowed. While the default policy doesn&#39;t restrict connections to hosts, be careful when explicitly adding either the <code>connect-src</code> or <code>default-src</code> directives.</p><p>Updated on Monday, March 9, 2020 \u2022 <a href="https://github.com/GoogleChrome/developer.chrome.com/blob/main/site/en/docs/extensions/mv3/xhr/index.md" target="_blank" rel="noreferrer">Improve article</a></p>`,39),i=[n];function a(c,h,l,p,d,u){return t(),r("div",null,i)}const f=e(s,[["render",a]]);export{m as __pageData,f as default};
